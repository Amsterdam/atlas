import { gefaseerdeBegrotingCategories } from '../grondexploitatie-categories';

const generateValue = (begroot) => ({
  value: begroot / 1000000
});

// generate object with all the categories as keys and default values
const getDefaultCategories = () => {
  const defaultCategories = {};
  gefaseerdeBegrotingCategories.forEach((category) => {
    defaultCategories[category] = generateValue(0);
  });
  return defaultCategories;
};

// data is a array with categories, a category has prop years 'jaren' this is an array
// we want to convert the array of categories to an array of years 'jaren'
// see mock file
const getAllYears = (categories) => [].concat(
  ...categories.map((item) => item.jaren.map((year) => ({
    name: year.start !== year.end ? `${year.start} - ${year.end}` : year.start,
    [item.categorie]: generateValue(year.begroot)
  }))));

// merge the years with the same name property
const mergeYears = (years) => years.reduce((acc, current) => {
  const index = acc.findIndex((item) => item.name === current.name);
  if (index > -1) {
    return [
      ...acc.slice(0, index),
      { ...acc[index], ...current },
      ...acc.slice(index + 1, acc.length)
    ];
  }
  return [
    ...acc,
    { ...getDefaultCategories(), ...current }
  ];
}, []);

// sort years based on the name property
const sortYears = (data) => (data.sort((a, b) => {
  const nameA = a.name.toUpperCase();
  const nameB = b.name.toUpperCase();
  // because this method is chained after `mergeYears` there are no duplicate items
  return nameA < nameB ? -1 : 1;
}));

const generateGraphData = (data) => {
  const years = getAllYears(data);
  const merged = mergeYears(years);
  const sorted = sortYears(merged);
  return sorted;
};

export default generateGraphData;
