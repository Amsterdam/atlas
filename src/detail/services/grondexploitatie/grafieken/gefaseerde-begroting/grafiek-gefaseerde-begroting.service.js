import { gefaseerdeBegrotingCategories, CATEGORY_LABELS } from '../grondexploitatie-categories';
import { displayFactor, precisionRound } from '../helpers';

// data is a array with categories, a category has prop years 'jaren' this is an array
// we want to convert the array of categories to an array of years 'jaren'
// see mock file
const getAllYears = (categories) => [].concat(
  ...categories.map((item) => item.jaren.map((year) => {
    const begrootRounded = precisionRound(year.begroot / displayFactor, 1);
    return {
      name: year.start !== year.end ? `${year.start} - ${year.end}` : year.start,
      data: [{
        name: CATEGORY_LABELS[item.categorie],
        id: item.categorie,
        begroot: {
          value: year.begroot / displayFactor,
          label: begrootRounded ? `${begrootRounded}`.replace('.', ',') : ''
        }
      }]
    };
  })));

// merge the years with the same name property
const mergeYears = (years) => years.reduce((acc, current) => {
  const index = acc.findIndex((item) => item.name === current.name);
  if (index > -1) {
    return [
      ...acc.slice(0, index),
      {
        name: acc[index].name,
        data: [
          ...acc[index].data,
          ...current.data
        ]
      },
      ...acc.slice(index + 1, acc.length)
    ];
  }
  return [
    ...acc,
    { ...current }
  ];
}, []);

// sort years based on the name property
const sortYears = (data) => (data.sort((a, b) => {
  const nameA = a.name.toUpperCase();
  const nameB = b.name.toUpperCase();
  // because this method is chained after `mergeYears` there are no duplicate items
  return nameA < nameB ? -1 : 1;
}));

const fillCategories = (data) => data.map((year) => ({
  name: year.name,
  data: gefaseerdeBegrotingCategories.map((category) =>
    year.data.find((item) => item.id === category) || {
      name: CATEGORY_LABELS[category],
      id: category,
      begroot: { value: 0 }
    }
  )
}));

const generateGraphData = (data) => {
  const years = getAllYears(data);
  const merged = mergeYears(years);
  const sorted = sortYears(merged);
  return fillCategories(sorted);
};

export default generateGraphData;
