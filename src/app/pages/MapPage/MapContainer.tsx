import { Geometry } from 'geojson'
import { LatLngLiteral, TileLayerOptions } from 'leaflet'
import React from 'react'
import {
  getMapBaseLayers as fetchBaseLayers,
  getMapLayers as fetchMapLayers,
  getPanelLayers as fetchPanelLayers,
} from '../../../map/services'
import MAP_CONFIG from '../../../map/services/map.config'
import { createUrlWithToken } from '../../../shared/services/api/api'
import getState from '../../../shared/services/redux/get-state'
import PARAMETERS from '../../../store/parameters'
import watchForChanges, { getFromURL } from '../../utils/watchForChanges'
import MapContext, {
  ActiveMapLayer,
  initialState,
  MapContextProps,
  MapLayer,
  MapState,
  Overlay,
} from './MapContext'
import MapPage from './MapPage'

// Add more autogenerated types
type Action =
  | { type: 'setActiveBaseLayer'; payload: string }
  | { type: 'getBaseLayers'; payload: Array<Object> }
  | { type: 'getPanelLayers'; payload: Array<Object> }
  | { type: 'getMapLayers'; payload: Array<MapLayer> }
  | { type: 'setActiveMapLayers'; payload: Array<ActiveMapLayer> }
  | { type: 'setVisibleMapLayer'; payload: ActiveMapLayer }
  | { type: 'setOverlays'; payload: Array<Overlay> }
  | { type: 'setLocation'; payload: LatLngLiteral | null }
  | { type: 'setDetailUrl'; payload: string | null }
  | { type: 'setGeometry'; payload: Geometry }
  | { type: 'addDrawingGeometry'; payload: LatLngLiteral[] }
  | { type: 'addDrawingGeometries'; payload: LatLngLiteral[][] }
  | { type: 'deleteDrawingGeometry'; payload: LatLngLiteral[] }
  | { type: 'resetDrawingGeometries' }

const reducer = (state: MapState, action: Action): MapState => {
  switch (action.type) {
    case 'setActiveBaseLayer':
      return {
        ...state,
        activeBaseLayer: action.payload,
      }
    case 'getBaseLayers':
      return {
        ...state,
        baseLayers: action.payload,
      }
    case 'getPanelLayers':
      return {
        ...state,
        panelLayers: action.payload,
      }
    case 'getMapLayers':
      return {
        ...state,
        mapLayers: action.payload,
      }
    case 'setActiveMapLayers':
      // TODO: simplify this in the new MapPanel
      return {
        ...state,
        activeMapLayers: state.activeMapLayers.some((overlay) =>
          action.payload.map(({ id }) => id).includes(overlay.id),
        )
          ? [
              ...state.activeMapLayers.filter((overlay) => {
                return !action.payload.map(({ id }) => id).includes(overlay.id)
              }),
            ]
          : [
              ...state.activeMapLayers,
              ...action.payload.map(({ id: mapLayerId, isVisible }) => ({
                id: mapLayerId,
                isVisible,
              })),
            ],
      }
    case 'setVisibleMapLayer':
      // TODO: simplify this in the new MapPanel
      return {
        ...state,
        activeMapLayers: state.activeMapLayers.map((overlay) => ({
          ...overlay,
          isVisible:
            overlay.id === action.payload.id ? action.payload.isVisible : overlay.isVisible,
        })),
      }
    case 'setOverlays':
      return {
        ...state,
        overlays: action.payload,
      }
    case 'setLocation':
      return {
        ...state,
        location: action.payload,
      }
    case 'setDetailUrl':
      return {
        ...state,
        detailUrl: action.payload,
      }
    case 'setGeometry':
      return {
        ...state,
        geometry: action.payload,
      }
    case 'addDrawingGeometry': {
      if (
        !state.drawingGeometries?.find(
          (drawingGeometry) => JSON.stringify(drawingGeometry) === JSON.stringify(action.payload),
        )
      ) {
        return {
          ...state,
          drawingGeometries: state.drawingGeometries?.length
            ? [...state.drawingGeometries, action.payload]
            : [action.payload],
        }
      }

      return state
    }
    case 'addDrawingGeometries':
      return {
        ...state,
        drawingGeometries: action.payload,
      }

    case 'deleteDrawingGeometry':
      return {
        ...state,
        drawingGeometries: state.drawingGeometries?.filter(
          (drawingGeometry) => JSON.stringify(drawingGeometry) !== JSON.stringify(action.payload),
        ),
      }
    case 'resetDrawingGeometries':
      return {
        ...state,
        drawingGeometries: [],
      }
    default:
      return state
  }
}

const MapContextProvider: React.FC<MapContextProps> = ({ children }) => {
  const [state, dispatch] = React.useReducer(reducer, initialState)

  function setActiveBaseLayer(payload: string) {
    dispatch({ type: 'setActiveBaseLayer', payload })
  }

  // Add auto type generation
  function setActiveMapLayers(payload: Array<ActiveMapLayer>) {
    dispatch({ type: 'setActiveMapLayers', payload })
  }

  function setVisibleMapLayer(id: string, isVisible: boolean) {
    dispatch({ type: 'setVisibleMapLayer', payload: { id, isVisible: !isVisible } })
  }

  function setLocation(location: LatLngLiteral | null) {
    dispatch({ type: 'setLocation', payload: location })
  }

  function setDetailUrl(payload: string | null) {
    dispatch({ type: 'setDetailUrl', payload })
  }

  function setGeometry(payload: Geometry) {
    dispatch({ type: 'setGeometry', payload })
  }

  function addDrawingGeometry(payload: LatLngLiteral[]) {
    dispatch({ type: 'addDrawingGeometry', payload })
  }

  function addDrawingGeometries(payload: LatLngLiteral[][]) {
    dispatch({ type: 'addDrawingGeometries', payload })
  }

  function deleteDrawingGeometry(payload: LatLngLiteral[]) {
    dispatch({ type: 'deleteDrawingGeometry', payload })
  }

  function resetDrawingGeometries() {
    dispatch({ type: 'resetDrawingGeometries' })
  }

  async function getBaseLayers() {
    const baseLayers = (await fetchBaseLayers()) as Array<{ category: string }> // Add auto type generation

    dispatch({
      type: 'getBaseLayers',
      // @ts-ignore auto generate types
      payload: baseLayers.reduce(
        (result, item) => ({
          ...result,
          // @ts-ignore auto generate types
          [item.category]: result[item.category] ? [...result[item.category], item] : [item],
        }),
        {},
      ),
    })
  }

  async function getPanelLayers() {
    const panelLayers = await fetchPanelLayers()

    dispatch({
      type: 'getPanelLayers',
      payload: panelLayers,
    })
  }

  async function getMapLayers() {
    const mapLayers = await fetchMapLayers()

    dispatch({
      type: 'getMapLayers',
      payload: mapLayers,
    })
  }

  const findLayer = (layers: MapLayer[], id: string) => {
    const idParts = id.split('-').reverse()
    return layers.find((layer) => idParts.includes(layer.id)) ?? null
  }

  const generateOverlay = (layer: MapLayer, token: string) => {
    if (layer.authScope && !token) {
      return null
    }

    const url = generateUrl(layer, token)

    if (!url) {
      return null
    }

    const params = layer.params ? Object.fromEntries(new URLSearchParams(layer.params)) : undefined

    const overlay: Overlay = {
      id: layer.id,
      type: layer.type,
      params,
      url,
      options: {
        ...MAP_CONFIG.OVERLAY_OPTIONS,
        layers: layer.layers?.join(','),
        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/15313
      } as TileLayerOptions,
    }

    return overlay
  }

  function generateUrl(layer: MapLayer, token: string) {
    if (!layer.url) {
      return null
    }

    const url = layer.external ? layer.url : `${MAP_CONFIG.OVERLAY_ROOT}${layer.url}`

    if (layer.authScope) {
      return createUrlWithToken(url, token)
    }

    return url
  }

  // TODO: Use a better name than 'getOverlays', either way this value can be placed in the reducer.
  function getOverlays() {
    const { user } = getState()
    const { activeMapLayers, mapLayers } = state

    const overlays = activeMapLayers
      .map((activeMapLayer) => {
        const layer = findLayer(mapLayers, activeMapLayer.id)

        if (!layer) {
          return null
        }

        const legendLayers = (layer.legendItems ?? [])
          // eslint-disable-next-line no-underscore-dangle
          .map((legendItem) => (legendItem.__typename === 'MapLayer' ? legendItem.id : null))
          .filter((id): id is string => !!id)
          .map((id) => findLayer(mapLayers, id))
          .filter((legendLayer): legendLayer is MapLayer => !!legendLayer)

        return [layer, ...legendLayers].map((item) => generateOverlay(item, user.accessToken))
      })
      .flat()
      .filter((layer): layer is Overlay => !!layer)

    dispatch({
      type: 'setOverlays',
      payload: overlays,
    })
  }

  // Load the state from the query parameters
  const [drawingGeometries] = getFromURL([PARAMETERS.DRAWING_GEOMETRY])

  // Watch for state or URL changes
  watchForChanges(PARAMETERS.MAP_BACKGROUND, state.activeBaseLayer, setActiveBaseLayer)
  watchForChanges(PARAMETERS.LOCATION, state.location, setLocation)
  watchForChanges(
    PARAMETERS.DRAWING_GEOMETRY,
    state.drawingGeometries,
    addDrawingGeometries,
    !!drawingGeometries, // Only the last drawing state is stored in the history to avoid having to rerender the map to force leaflet-draw to delete drawings that dont exist in the state
  )
  watchForChanges(PARAMETERS.LAYERS, state.activeMapLayers, setActiveMapLayers)
  watchForChanges(PARAMETERS.DETAIL, state.detailUrl, setDetailUrl)

  return (
    <MapContext.Provider
      value={{
        ...state,
        setActiveBaseLayer,
        setActiveMapLayers,
        setVisibleMapLayer,
        setLocation,
        setDetailUrl,
        setGeometry,
        addDrawingGeometry,
        addDrawingGeometries,
        deleteDrawingGeometry,
        resetDrawingGeometries,
        getBaseLayers,
        getPanelLayers,
        getMapLayers,
        getOverlays,
      }}
    >
      {children}
    </MapContext.Provider>
  )
}

const MapContainer: React.FC<{}> = () => (
  // @ts-ignore find out the problem
  <MapContextProvider>
    <MapComponent />
  </MapContextProvider>
)

const MapComponent = () => {
  const { getBaseLayers, getPanelLayers, getMapLayers } = React.useContext(MapContext)

  React.useEffect(() => {
    getBaseLayers()
    getPanelLayers()
    getMapLayers()
  }, [])

  return <MapPage />
}

export default MapContainer
